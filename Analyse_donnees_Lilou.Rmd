---
title: "Analyse_donnees_Lilou"
author: "Basile PAJOT"
date: "2025-06-18"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r, include=FALSE}
# Useful variables
my_theme <- theme_bw() +
  theme(text = element_text(size = 15))
```



# Importer le(s) librarie(s)

La librairie principale qui va nous servir pour l'instant est `tidyverse`. C'est une librairie composée de plusieurs autres (`dplyr`, `stringr`, `ggplot2`, ...) utilisée pour faire du traitement de données et de la représentation graphique de ces données. 
La première étape est donc d'importer cette librairie.
```{r}
library("tidyverse")
```


# Importer le jeu de données
Le jeu de données est un tableau tsv/csv. Pour l'importer, nous allons utiliser la fonction `read.table` qui nous permet de lire un tableau de données.
```{r}
# Définition du chemin d'accès au jeu de données. Cette ligne sera sûrement à changer sur ta machine.
path_data <- "C:/Users/Basile Pajot/Documents/Pro/Thèse/Projet/Manips/Manip_sexualselection1/Data/Offspring_phenotypes.tsv"
# Importation jeu de données
Offspring_data <- read.table(file = path_data,             # Où est le jeu de données
                             sep = "\t",                   # Le séparateur utilisé. Pour un fichier csv, tu peux mettre ","
                             header = TRUE,                # Utile si la première ligne du jeu de données contient les noms de colonnes.
                             dec = ",")                    # Indique comment utiliser quel séparateur décimal utiliserS
```

Une fois importé, le jeu de données doit être nettoyé. On peut par exemple commencer par renomer une colonne pour compenser une erreur de frappe.
Certaines colonnes contiennent aussi des valeurs maximales de soies comptées (notées ">40" pour les parties où il y a plus de 40 soies, mais seules 40 sont décernables). Nous allons donc nous débarasser de ces ">" en utilisant la fonction `mutate` en combinaison avec `across` qui nous permet de modifier plusieurs colonnes en une ligne. 
```{r}
# Il y a des ">" dans le jeu de données dont on aimerait se débarasser. Pour se faire, on repère les colonnes dans lesquelles on a des ">" avec:
columns_with_signs <- which(grepl(">", Offspring_data))
column_names <- colnames(Offspring_data)

# On modifie ces colonnes pour enlever les ">" et transformer le tout en valeurs numériques
Offspring_data <- Offspring_data %>% 
  rename(P4.isch.curv.setae = P4.isch.cirv.setae) %>% 
  mutate(across(column_names[columns_with_signs], ~ str_remove_all(., ">")),
         across(column_names[columns_with_signs], ~ as.numeric(.)),
         Isolation_date = as.Date(Isolation_date, "%d/%m/%Y"))


```

Étant donné que ce tableau contient des phénotypes pour les mâles et les femelles, et que nous allons nous intéresser pour l'instant uniquement aux mâles, nous pouvons sous-chantillonner le jeu de données pour ne garder que les mâles. Pour cela, nous allons utiliser la fonction `filter` qui nous permet de filtrer une (ou plusieurs) colonne(s) pour ne garder que les lignes vérifiant une condition.
```{r}
Offspring_males <- Offspring_data %>% 
  filter(Sex == "M")                                       # La condition ici est que la colonne "Sex" soit égale à la chaine de charactère "M"
```

Nous utilisons également le *pipe* `%>%` qui nous permet d'injecter un tableau (par exemple) dans une fonction. Au dessus, le pipe permet d'injecter le tableau `Offspring_data` dans la fonction `filter`.

## Données manquantes
La prochaine étape est de regarder le nombre de données manquantes. On peut le faire par lignes ou par colonnes. Dans notre jeu de données, chaque ligne représente un individu donc il est plus simple de regarder le nombre de données manquantes par individus pour enlever ceux qui ne nous conviennent pas. On peut par exemple enlever les individus avec plus de 5% de données manquantes (95% de données renseignées).
Pour faire ça, on peut fabriquer une fonction qui calcule directement le pourcentage de données manquantes pour chaque individu. Nous allons décomposer cela en deux fonction. La première calcule le nombre de données manquantes et la seconde utilise la première pour calculer la proportion de valeurs manquantes.
```{r}
# D'abord, faisons une fonction qui compte le nombre de données manquantes.
Count_NA <- function(df,                  # Cet argument est un data frame qui peut contenir des valeurs manquantes.
                     by_row = TRUE){      # Cet argument permet de choisir si on veut le nombre de données manquantes par ligne ou colonne. Par défaut, ce calcul se fait par ligne.
  # Ici, on choisit comment calculer le nombre de données manquantes (par lignes ou colonnes). On attribue une fonction à la variable temporaire ..function2use..
  ..function2use.. <- ifelse(by_row, rowSums, colSums)
  
  # Puis on calcule le nombre de données manquantes en fonction de ce qu'on a choisi.
  df %>% 
    is.na() %>%                     # La fonction is.na() retourne TRUE pour chaque NA rencontré dans le tableau d'entrée.
    ..function2use..() %>%          # Comme on a TRUE = 1 et FALSE = 0, on peut faire la somme de chaque TRUE pour connaître le nombre de données manquantes.
    return()                        # On utilise la fonction return en fin de fonction pour dire à notre fonction de retourner le calcul effectué.
}

# Puis la fonction qui détermine la proportion de données manquantes
Calculate_percentages_NA <- function(df, by_row = TRUE){         # Comme on va ré-utiliser la fonction qui compte les NA, on doit avoir au moins les mêmes arguments.
  # D'abord, il faut qu'on choisisse par quelle dimension on divise. Par exemple, si on veut la proportion de valeurs manquantes par ligne, il faut diviser le nombre de données manquantes par le nombre de colonnes du tableau. La variable ..dimension2use.. vaut donc 2 dans ce cas, car le nombre de colonnes est à la deuxième position quand on utilise la fonction dim(df).
  ..dimension2use.. <- ifelse(by_row, 2, 1)
  
  # Puis on calcule le nombre de valeurs manquantes en utilisant la fonction préparée au dessus
  ..nb_NA.. <- Count_NA(df = df, by_row = by_row)
  
  # Et enfin, on calcule la proportion de valeurs manquantes
  ..missing_proportion.. <- ..nb_NA.. / dim(df)[..dimension2use..]
  # Qu'on retourne ici
  return(..missing_proportion..)
}
```

Une fois que nous avons fait ces fonctions, utilisons les pour trouver les individus qui ont plus de 5% de données manquantes.Cependant, pour faire ça, nous devons sous-échantillonner le tableau pour ne garder que les phénotypes (les valeurs qui nous intéressent pour les analyses). Nous pouvons faire ça avec la fonction `select` qui nous permet de sélectionner des colonnes par nom dans le tableau.
Comme tous les noms des colonnes qui contiennent des phénotypes commencent par "P" et un nombre entre 1 et 7, nous allons utiliser `select` en combinaison avec la fonction `starts_with` pour sélectionner toutes les colonnes qui commencent par "P" et un nombre entre 1 et 7.
```{r}
# D'abord, faisons un vecteur des débuts de colonnes (de "P1" à "P7")
columns_to_keep <- paste0("P", 1:7)          # On utilise la fonction `paste` qui nous permet de coller du texte. Ici on colle la lettre "P" à chaque chiffre de la séquence 1:7.

# On sous-échantillonne le tableau pour ne garder que les colonnes qui nous intéressent
Phenotypes_males <- Offspring_males %>% 
  select(starts_with(columns_to_keep))

# On calcule le nombre de données manquantes
Individual_NA_ratio <- Calculate_percentages_NA(Phenotypes_males, by_row = TRUE) %>%
  round(digits = 2)

```

Maintenant qu'on a obtenu le pourcentage de valeurs manquantes par ligne, on peut chercher quels sont les individus qui ont plus de 5% de NA. Pour cela, nous allons utiliser la fonction `which` qui nous permet de retourner les indices (les positions dans le vecteur) des éléments du vecteur qui sont TRUE.
```{r}
# D'abord, on veut voir si les individus on plus de 5% de données manquantes
Missing_threshold <- 0.05
Is_percentage_over_threshold <- Individual_NA_ratio > Missing_threshold
# Ceci nous donne un vecteur avec des TRUE et FALSE. On peut donc utiliser which pour trouver les indices des TRUE
Indices_over_threshold <- which(Is_percentage_over_threshold)
```
On a donc 18 individus pour lesquels on dépasse le seuil qu'on a fixé à 5%. Ce seuil est très conservatif et peut être assoupli un peu (jusqu'à 20%), mais ici, essayons de continuer avec ce seuil de valeurs manquantes. 
La prochaine étape est donc de retirer ces individus. On peut faire ça de plusieurs façons. On peut soit utiliser les indices des individus qu'on vient de trouver, soit utiliser une méthode plus directe:
```{r}
# D'abord, en utilisant les indices des individus dont on veut se débarasser:
## Les indices des individus qu'on a récupéré au-dessus correspondent au numéro de ligne sur lequel les individus sont dans le tableau de données. On peut donc enlever les individus en disant qu'on ne veut pas les lignes identifiées au-dessus.
Offspring_males_without_NA <- Offspring_males[-Indices_over_threshold, ]

# La deuxième méthode plus directe utilise la fonction filter
Offspring_males_without_NA <- Offspring_males %>% 
  filter(Calculate_percentages_NA(Phenotypes_males) < Missing_threshold)

# Et faisons de même pour les femelles.
Offspring_females_without_NA <- Offspring_data %>% 
  filter(Sex == "F") %>% 
  filter(Calculate_percentages_NA(Offspring_data %>% 
                                    filter(Sex == "F") %>% select(starts_with(columns_to_keep))) < Missing_threshold)

Offspring_data_without_NA <- Offspring_females_without_NA %>% 
  rbind(Offspring_males_without_NA)
  
```

Nous allons donc maintenant toujours utiliser ce tableau de données filtrées pour faire les analyses.



# Exploration du jeu de données


## Nombre de d'individus de chaque espèce
Les mâles peuvent être identifiés pour chaque espèce en fonction du phénotype et c'est ce qui est indiqué dans la colonne `Phenotype` du jeu de données. Nous voulons voir combien il y a de mâles de chaque espèce.
```{r}
Offspring_males_without_NA %>% 
  ggplot() +
  geom_bar(aes(x = Phenotype, fill = Phenotype), colour = "black") +
  scale_fill_manual(values = c("forsmani" = "lightcoral", "hybrid" = "plum2", "praehirsuta" = "dodgerblue3", "NA" = "grey")) +
  labs(y = "Number of individuals") +
  my_theme
```
Il semble qu'il y ait des individus avec des NA au niveau des phénotypes. Un des objectifs va être d'essayer de les attribuer à un phénotype.


## Distribution du nombre d'épines par pereiopode
On veut regarder la distribution du nombre total d'épines par pereiopode et par individu. Pour faire ça, on doit faire pivoter notre tableau pour avoir une colonne avec les noms des péréiopodes et une avec le nombre d'épines par pereiopode. Pour faire ça, on utilise la fonction `pivot_longer`.
```{r}
Offspring_males_without_NA %>% 
  rename(P4.ep = P4.small.ep) %>%                     # On renome une colonne pour qu'on puisse la sélectionner avec les autres
  select(paste0("P", 4:7, ".ep"), Phenotype) %>%      # On sélectionne les colonnes qu'on veut faire pivoter
  pivot_longer(cols = -Phenotype,                     # Quelles colonnes faire pivoter?
               names_to = "Pereiopod",                # Comment s'appelle la colonne dans laquelle les anciens noms de colonne se retrouvent?
               values_to = "Number_spines") %>%       # Comment s'appelle la colonne dans laquelle les anciennes valeurs se retrouvent?
  mutate(Pereiopod = Pereiopod %>% str_remove_all(., ".ep")) %>%     # On enlève la terminaison du nom de colonne
  ggplot(aes(x = Pereiopod, y = Number_spines, fill = Phenotype)) +  # On commence la représentation graphique
  geom_boxplot() +
  facet_wrap(vars(Phenotype)) +                       # Ceci permet de faire un graphique pour chaque phenotype
  scale_fill_manual(values = c("forsmani" = "lightcoral", "hybrid" = "plum2", "praehirsuta" = "dodgerblue3", "NA" = "grey")) +
  labs(y = "Number of spines per pereiopod") +
  my_theme
```
On observe qu'on a des différences entre le nombre d'épines entre les deux espèces, en particulier sur le P6. Pour forsmani, on au moins deux épines sur le P6 là où chez praehirsuta, il semble y en avoir moins en moyenne. Les hybrides semblent avoir un nombre d'épines intermédiaire entre forsmani et praehirsuta. Il faut cependant vérifier que les nombres d'épines sont significativement différents entre espèces, ce qui ne semble pas être le cas étant donné que les intervalles de confiance des boxplots se recoupent (peut mieux se voir sur le graphique suivant).
```{r}
Offspring_males_without_NA %>% 
  rename(P4.ep = P4.small.ep) %>% 
  select(paste0("P", 4:7, ".ep"), Phenotype) %>% 
  pivot_longer(cols = -Phenotype,
               names_to = "Pereiopod",
               values_to = "Number_spines") %>%
  mutate(Pereiopod = Pereiopod %>% str_remove_all(., ".ep")) %>% 
  filter(Phenotype %in% c("forsmani", "praehirsuta")) %>%
  ggplot(aes(x = Pereiopod, y = Number_spines, fill = Phenotype)) +
  geom_boxplot() +
  scale_fill_manual(values = c("forsmani" = "lightcoral", "hybrid" = "plum2", "praehirsuta" = "dodgerblue3", "NA" = "grey")) +
  labs(y = "Number of spines per pereiopod") +
  my_theme
```


## Distribution du nombre de soies par pereiopode
De la même façon que pour le nombre d'épines, on veut voir si on trouve une différence dans le nombre de soies entre espèces.
```{r}
Offspring_males_without_NA %>%
  rename(P6.curv.setae = P6.carp.curv.setae) %>% 
  select(paste0("P", 1:6, ".curv.setae"), Phenotype) %>%
  pivot_longer(cols = -Phenotype,
               names_to = "Pereiopod",
               values_to = "Number_setae") %>% 
  mutate(Pereiopod = Pereiopod %>% str_remove_all(., ".curv.setae")) %>% 
  ggplot() +
  geom_boxplot(aes(x = Pereiopod, y = Number_setae, fill = Phenotype)) +
  facet_wrap(vars(Phenotype)) +
  scale_fill_manual(values = c("forsmani" = "lightcoral", "hybrid" = "plum2", "praehirsuta" = "dodgerblue3", "NA" = "grey")) +
  labs(y = "Number of curved setae per pereiopod") +
  my_theme
```
On observe que les praehirsuta ont nettement plus de soies courbes que les forsmani (qui n'en ont presque pas). Les hybrides ont quelques soies, mais leur nombre reste tout de même inférieur à ceux des praehirsuta purs. A nouveau, il faut faire un test stat pour être certain que ces différences entre espèces et avec les hybrides entre espèces sont significatives.

## Distribution de taille
### Entre sexes
Nous avons une distribution de taille différente entre les sexes. Les femelles sont plus grandes que les mâles. Nous pouvons observer ça en regardant la distribution de taille entre les différents sexes.
```{r}
Offspring_data_without_NA %>% 
  ggplot() +
  geom_density(aes(x = Size, fill = Sex), alpha = 0.5)
```
Les différences de taille entre les sexes semble claire, mais on ne sait pas si elles sont significativement différentes ou non.

### Entre espèces
Il semble également y avoir deux pics dans la distribution de taille des individus mâles dans le graphique précédent. On peut donc regarder si les individus des espèces différentes ont des tailles différentes.
```{r}
Offspring_data_without_NA %>% 
  filter(Sex == "M") %>% 
  ggplot() +
  geom_density(aes(x = Size, fill = Phenotype), alpha = 0.5)+
  scale_fill_manual(values = c("forsmani" = "lightcoral", "hybrid" = "plum2", "praehirsuta" = "dodgerblue3", "NA" = "grey")) +
  my_theme
```
Il semble que les distributions de taille des deux espèces soit différentes avec des praehirsuta qui sont plus petits que les forsmani. Les hybrides semblent avoir des tailles intermédiaires entre les deux espèces. 

### Corrélation taille nombre d'épines
#### Males
```{r}
Offspring_males_without_NA %>% 
  rename(P4.ep = P4.small.ep) %>% 
  select(paste0("P", 4:7, ".ep"), Phenotype, Size) %>% 
  pivot_longer(cols = -c(Phenotype, Size),
               names_to = "Pereiopod",
               values_to = "Number_spines") %>%
  mutate(Pereiopod = Pereiopod %>% str_remove_all(., ".ep")) %>%
  ggplot() +
  geom_point(aes(x = Size, y = Number_spines)) +
  facet_wrap(vars(Phenotype)) +
  my_theme
```

#### Femelles
```{r}
Offspring_females_without_NA %>% 
  rename(P4.ep = P4.small.ep) %>% 
  select(paste0("P", 4:7, ".ep"), Size) %>% 
  pivot_longer(cols = -Size,
               names_to = "Pereiopod",
               values_to = "Number_spines") %>% 
  ggplot() +
  geom_point(aes(x = Size, y = Number_spines)) +
  my_theme
```

### Corrélation taille nombre de soies
```{r}
Offspring_males_without_NA %>% 
  rename(P6.curv.setae = P6.carp.curv.setae) %>% 
  select(paste0("P", 1:6, ".curv.setae"), Phenotype, Size) %>%
  pivot_longer(cols = -c(Phenotype, Size),
               names_to = "Pereiopod",
               values_to = "Number_setae") %>% 
  mutate(Pereiopod = Pereiopod %>% str_remove_all(., ".curv.setae")) %>%
  ggplot() +
  geom_point(aes(x = Size, y = Number_setae)) +
  facet_wrap(vars(Phenotype)) +
  my_theme
```

## Différence de phénologie entre espèces
```{r}
Offspring_males_without_NA %>% 
  ggplot() +
  geom_histogram(aes(x = Isolation_date, fill = Phenotype), bins = 30) +
  facet_wrap(vars(Phenotype), ncol = 1) +
  my_theme +
  labs(x = "Date d'isolation")
```

